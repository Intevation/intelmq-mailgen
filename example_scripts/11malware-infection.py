import copy
import datetime

from intelmqmail.tableformat import build_table_format
from intelmqmail.notification import Postponed


SPECIAL_MATTERS = [ 'avalanche',
                    'ebury',
                    'mumblehard'
                  ]

MATTER = 'malware-infection'
# Minimum age of the newest of a group of directives being aggregated
#
# The value should be chosen such that it's very unlikely that any more
# directives will be added to the event database that would end up in
# the same aggregation when the newest directive has reached at least
# this age.
minimum_directive_age = datetime.timedelta(minutes=15)
minimum_observation_age = datetime.timedelta(hours=2)


def create_notifications(context):
    matter = context.directive.notification_format

    # Copy Substitutions from the context to this script.
    # This way we can edit the variables in this script
    # without changing the context.
    substitution_variables = copy.copy(context.substitutions)

    data_format = context.directive.event_data_format

    if matter in SPECIAL_MATTERS:
        # Prepare Message in CSV-Format for avalanche,
        # ebury, mumblehard
        formats = (
            ("source.asn", "ASN"),
            ("source.ip", "IP"),
            ("time.source", "Time"),
            ("classification.identifier", "Identifier"),
            ("malware.name", "Malware"),
            ("source.port", "Port"),
            ("destination.ip", "Destination-IP"),
            ("destination.port", "Destination-Port"),
            ("destination.fqdn", "Destination-FQDN"))

    elif matter == MATTER:
        # Prepare Message in CSV-Format for other matters,
        # most likely shadowserver sinkhole data
        formats = (
            ("source.asn", "asn"),
            ("source.ip", "ip"),
            ("time.source", "timestamp"),
            ("classification.identifier", "malware"),
            ("source.port", "src_port"),
            ("destination.ip", "dst_ip"),
            ("destination.port", "dst_port"),
            ("destination.fqdn", "dst_host"),
            ("protocol.transport", "proto"))

    else:
        return None

    # TODO: Update this mechanism!
    # If the matter is not a SPECIAL_MATTER, use the common notification_interval
    if matter not in SPECIAL_MATTERS:
        if not context.notification_interval_exceeded():
            return Postponed
    else:
        # If the matter is a SPECIAL_MATTER, it should be aggregatable by time.observation
        # (32ct_botnet-drone.py should have done that!)
        time_observation = context.directive.get_aggregation_item("time.observation")
        if time_observation is not None:
            observation_age = context.now - time_observation
        else:
            observation_age = 0
        if (context.age_of_newest_directive() < minimum_directive_age
            and observation_age < minimum_observation_age):
            return Postponed

    csv_format = build_table_format(matter, formats)

    return create_csv_mail(data_format, csv_format, substitution_variables, context)


def create_csv_mail(data_format, csv_format, substitution_variables, context):
    if data_format.endswith("_csv_inline"):
        # If Inline-Messages are wanted
        substitution_variables["data_location_en"] = substitution_variables["data_location_inline_en"]
        substitution_variables["data_location_de"] = substitution_variables["data_location_inline_de"]
        return context.mail_format_as_csv(csv_format, substitutions=substitution_variables)

    elif data_format.endswith("_csv_attachment"):
        # If Inline-Messages are wanted
        # TODO There is no attachment, yet!
        substitution_variables["data_location_en"] = substitution_variables["data_location_attached_en"]
        substitution_variables["data_location_de"] = substitution_variables["data_location_attached_de"]
        substitution_variables["data_inline_separator_en"] = ""
        substitution_variables["data_inline_separator_de"] = ""
        return context.mail_format_as_csv(csv_format, substitutions=substitution_variables,
                                          attach_event_data=True)
